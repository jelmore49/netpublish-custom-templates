/**
 * local.np
 * @author Jay Elmore
 * This file defines several general convenience functions and some specific
 * functions to be used throughout the NetPublish template.
 */

/**
 * The xor() function returns the exclusive OR (XOR) of the two parameters,
 * since JavaScript does not have a built-in XOR operator. It returns true if
 * and only if one parameter is true and the other parameter is false, but
 * returns false if both parameters are either true or false.
 * This is a function so its usage in code is clear; if you wanted a simple
 * inline comparison without the overhead of a function call, you could use
 * (!a !== !b) directly.
 */
function xor(a, b) {
/*
 * We use the ! operator to switch each parameter from "truthy" to real
 * Booleans; this inverts the value of both parameters, so the comparison will
 * still work.
 * Then we return true if only one of them is false.
 */
    return (!a !== !b)
}

/**
 * The JavaScript engine used by Portfolio NetPublish is missing many useful
 * methods of the Array class that have been standardized in other engines
 * and made part of ECMAScript 5. So we will define some of these methods
 * here if they can be implemented as close to the ES5 spec as possible.
 */

/**
 * The Array.isArray() class method passes takes a parameter and returns true
 * if the typeof the parameter is "object and the toString() method of the
 * object returns "[object Array]", which is the most reliable method of
 * determining if an object is an array.
 */
if (typeof Array.isArray !== 'function') {
    Array.isArray = function isArray(obj) {
        return typeof o === 'object' &&
        Object.prototype.toString.call(obj) === '[object Array]';
    };
}

/**
 * The every() instance method passes each element of an array into a function
 * and returns true if the function returns true for each element. It takes
 * two parameters; the function to pass each element to, and an optional
 * scope object. The function must return either true or false.
 */
if (typeof Array.prototype.every !== 'function') {
    Array.prototype.every = function (fn, scopeObj) {
/*
 * We start a loop to handle each element of the array.
 */
        var i;
        for (i = 0; i < this.length; i += 1) {
/*
 * If the current element is undefined then we skip to the next one.
 */
            if (this[i] === undefined) {
                continue;
            }
/*
 * If not, then we call the supplied function on the current element; if it
 * returns false then we also return false and are done.
 */
            if (!fn(this[i], i, scopeObj)) {
                return false;
            }
        }
/*
 * If we get through the entire array without the function returning false then
 * we return true and are done.
 */
        return true;
    };
}

/**
 * The filter() instance method passes each element of an array into a function
 * and returns a new array of every element that the function returns true for.
 * It takes two parameters; the function to pass each element to, and
 * an optional scope object. The function must return either true or false.
 */
if (typeof Array.prototype.filter !== 'function') {
    Array.prototype.filter = function (fn, scopeObj) {
/*
 * The array "a" will hold our results.
 * We start a loop to handle each element of the array.
 */
        var i, a = [];
        for (i = 0; i < this.length; i += 1) {
/*
 * If the current element is undefined then we skip to the next one.
 */
            if (this[i] === undefined) {
                continue;
            }
/*
 * If the result of calling the function on the current element is false then
 * we also skip to the next one.
 */
            if (!fn(this[i], i, scopeObj)) {
                continue;
            }
/*
 * If the result is true then we push the element onto the result array.
 */
            a.push(this[i]);
        }
/*
 * When we've handled each element of the source array, we return the results.
 */
        return a;
    };
}

/**
 * The some() instance method passes each element of an array into a function
 * and returns false if the function returns false for each element.
 * It differs from Array.every() in that every() tells us if ALL of the elements
 * are "true", while some() tells us if ANY of the elements are "true".
 * It takes two parameters; the function to pass each element to, and
 * an optional scope object. The function must return either true or false.
 */
if (typeof Array.prototype.some !== 'function') {
    Array.prototype.some = function (fn, scopeObj) {
/*
 * We start a loop to handle each element of the array.
 */
        var i;
        for (i = 0; i < this.length; i += 1) {
/*
 * If the current element is undefined then we skip to the next one.
 */
            if (this[i] === undefined) {
                continue;
            }
/*
 * If not, then we call the supplied function on the current element; if it
 * returns true then we also return true and are done.
 */
            if (fn(this[i], i, scopeObj)) {
                return true;
            }
        }
/*
 * If we get through the entire array without the function returning true then
 * we return false and are done.
 */
        return false;
    };
}

/**
 * The forEach() instance method passes each element of an array into a
 * function that performs an operation using the element as a parameter.
 *
 * It is intended as a replacement for the for loop that iterates over every
 * element in an array. Instead of writing this:
 *
 *     for (i = 0; i < array.length; i++) {
 *          doSomething(array[i]);
 *     }
 *
 * you can write this:
 *
 *     array.forEach(doSomething);
 *
 * It takes two parameters; the function to pass each element to, and
 * an optional scope object.
 */
if (typeof Array.prototype.forEach !== 'function') {
    Array.prototype.forEach = function (fn, scopeObj) {
/*
 * We start a loop to handle each element of the array.
 */
        var i;
        for (i = 0; i < this.length; i += 1) {
/*
 * If the current element is undefined then we skip to the next one.
 */
            if (this[i] === undefined) {
                continue;
            }
/*
 * If not, then we call the supplied function on the current element.
 */
            fn(this[i], i, this);
        }
    };
}

/**
 * The map() instance method passes each element of an array into a function,
 * which performs an operation on the element used as a parameter, and returns
 * an array of the results. It differs from Array.forEach() in that forEach()
 * can potentially modify the elements in place, where map() creates a new
 * array for the results.
 *
 * It is intended as a replacement for the for loop that iterates over every
 * element in an array. Instead of writing this:
 *
 *     resultArray = [];
 *     for (i = 0; i < array.length; i++) {
 *         resultArray.push(doSomethingWith(array[i]));
 *     }
 *
 * you can write this:
 *
 *     resultArray = array.map(doSomethingWith);
 *
 * It takes two parameters; the function to pass each element to, and
 * an optional scope object.
 */
if (typeof Array.prototype.map !== 'function') {
    Array.prototype.map = function (fn, scopeObj) {
/*
 * We create an empty array to hold the results and start a loop to handle
 * each element of the array.
 */
        var i, results = [];
        for (i = 0; i < this.length; i += 1) {
/*
 * If the current element is undefined then we skip to the next one.
 */
            if (this[i] === undefined) {
                continue;
            }
/*
 * If not, then we call the supplied function on the current element and push
 * the result into the result array.
 */
            results.push(fn(this[i], i, scopeObj));
        }
/*
 * Once we have finished iterating through the array, we return the
 * new array containing the results.
 */
        return results;
    };
}

/*
 * The indexOf() instance method iterates through an array and returns the index
 * of the first appearance of the supplied element (or -1 if not found). The
 * start parameter is the array index to start searching on; if start is
 * negative, then we count backwards from the end of the array to determine
 * the starting index.
 */
if (typeof Array.prototype.indexOf !== 'function') {
    Array.prototype.indexOf = function (el, start) {
        var i, len = this.length;
/*
 * If start is not defined then we set it to 0 in order to start at the
 * beginning of the array.
 */
        start = start || 0;
/*
 * If the start parameter falls outside of the array, and the array has
 * at least one element, then we return -1 (not found).
 */
        if ((this.length === 0) || (Math.abs(start) >= this.length)) {
            return -1;
        }
/*
 * If the start parameter is negative, we count backwards from the end of
 * the array. Adding the start parameter to the array length is the same as
 * (len - Math.abs(start)).
 */
        if (start < 0) {
            start = this.length + start;
        }
/*
 * We start a loop to handle each element of the array, beginning with the
 * specified index.
 */
        for (i = start; i < this.length; i += 1) {
/*
 * If the current element is undefined then we skip to the next one.
 */
            if (this[i] === undefined) {
                continue;
            }
/*
 * If not, then we test the supplied object against the current element.
 * If they match then we return the current array index.
 * We use the triple equals so that JavaScript does not try to coerce the
 * object types to match; we should not succeed if we compare 1 (the number)
 * to "1" (the string).
 */
            if (this[i] === el) {
                return i;
            }
        }
/*
 * If we finish iterating through the array and do not find the supplied
 * object, then we return -1.
 */
        return -1;
    };
}

/*
 * The lastIndexOf() instance method iterates through an array and returns
 * the index of the last appearance of the supplied element (or -1 if
 * not found). The start parameter is the array index to start searching on;
 * if start is negative, then we count backwards from the end of the array
 * to determine the starting index.
 */
if (typeof Array.prototype.lastIndexOf !== 'function') {
    Array.prototype.lastIndexOf = function (el, start) {
        var i, len = this.length;
/*
 * If start is not defined then we set it to 0 in order to start at the
 * beginning of the array.
 */
        start = start || 0;
/*
 * If the start parameter falls outside of the array, and the array has
 * at least one element, then we return -1 (not found).
 */
        if ((this.length === 0) || (Math.abs(start) >= this.length)) {
            return -1;
        }
/*
 * If the start parameter is negative, we count backwards from the end of
 * the array. Adding the start parameter to the array length is the same as
 * (len - Math.abs(start)).
 */
        if (start < 0) {
            start = this.length + start;
        }
/*
 * We start a loop to handle each element of the array, beginning with the
 * last element in the array and counting backwards to the starting index.
 */
        for (i = this.length; i >= start; i -= 1) {
/*
 * If the current element is undefined then we skip to the next one.
 */
            if (this[i] === undefined) {
                continue;
            }
/*
 * If not, then we test the supplied object against the current element.
 * If they match then we return the current array index.
 * We use the triple equals so that JavaScript does not try to coerce the
 * object types to match; we should not succeed if we compare 1 (the number)
 * to "1" (the string).
 */
            if (this[i] === el) {
                return i;
            }
        }
/*
 * If we finish iterating through the array and do not find the supplied
 * object, then we return -1.
 */
        return -1;
    };
}

/*
 * The trim() instance method strips any whitespace characters from the
 * beginning and end of the string it is called on.
 */
if (typeof String.prototype.trim !== 'function') {
    String.prototype.trim = function () {
        var i,
/*
 * First, we strip any whitespace characters from the beginning of the string
 * with a regular expression.
 * We don't use ^\s* in the regex because that would match when there is no
 * whitespace, and replacing nothing with nothing is a waste.
 * We don't use ^\s+ because most regex engines optimize the ^\s\s* expression
 * to be faster.
 */
        result = this.replace(/^\s\s*/, '');
/*
 * Next, we start a loop to work backwards from the end of the string
 * to find the first non-whitespace character. This can be faster than using
 * something like String.replace(/\s*$/, '') because most regex engines do not
 * optimize end-of-string matching well.
 */
        for (i = result.length - 1; i >= 0; i -= 1) {
            if (/\S/.test(result.charAt(i))) {
                return result.substring(0, i + 1);
            }
        }
    };
}

/*
 * Now we come to the local NetPublish functions that we want to define.
 * We declare a variable, "Local", and set it to an object literal (with a
 * single property, "VERSION") to hold all of the functions we want to define.
 */
var Local;

if (Local === undefined) {
    Local = { VERSION: 0.5 };
}

/*
 * Then we create another object literal, "common", to hold the functions that
 * will be common to the site, regardless of which role the template serves.
 * In other files we can define other object literals for specific template
 * roles, to serve as a kind of namespacing.
 */
Local.common = {
    // Functions for manipulating collections
    addToCollectionURI: function (siteName, catalogAlias, itemID, returnTemplate, collectionName) {
        var uriBuffer = ['/netpub/server.np?add',
        'itemid=' + itemID,
        'site=' + siteName,
        'catalog=' + catalogAlias,
        'template=' + returnTemplate];
        if (collectionName) {
            uriBuffer.push('name=' + collectionName);
        }

        return uriBuffer.join('&amp;');
    },

    removeFromCollectionURI: function (siteName, catalogAlias, itemID, returnTemplate, collectionName) {
        var uriBuffer = ['/netpub/server.np?remove',
        'itemid=' + itemID,
        'site=' + siteName,
        'catalog=' + catalogAlias,
        'template=' + returnTemplate];
        if (collectionName) {
            uriBuffer.push('name=' + collectionName);
        }

        return uriBuffer.join('&amp;');
    },

    clearCollectionURI: function (siteName, catalogAlias, returnTemplate, collectionName) {
        var uriBuffer = ['/netpub/server.np?remove',
        'all',
        'site=' + siteName,
        'catalog=' + catalogAlias,
        'template=' + returnTemplate];
        if (collectionName) {
            uriBuffer.push('name=' + collectionName);
        }

        return uriBuffer.join('&amp;');
    },

    downloadCollectionURI: function (siteName, catalogAlias, returnTemplate, collectionName, filename) {
        var uriBuffer = ['/netpub/server.np?archive',
        'site=' + siteName,
        'catalog=' + catalogAlias,
        'template=' + returnTemplate,
        'filename=' + filename,
        'format=zip'];
        if (collectionName) {
            uriBuffer.push('name=' + collectionName);
        }

        return uriBuffer.join('&amp;');
    },

    showCollectionURI: function (siteName, catalogAlias, returnTemplate, collectionName, sortField) {
        var uriBuffer = ['/netpub/server.np?show',
        'site=' + siteName,
        'catalog=' + catalogAlias,
        'template=' + returnTemplate,
        'sorton=' + sortField];
        if (collectionName) {
            uriBuffer.push('name=' + collectionName);
        }

        return uriBuffer.join('&amp;');
    },

    // Use the "base" command if your template does not require access to the RecordSet object
    baseSearchURI: function (siteName, catalogAlias, returnTemplate) {
        return ['/netpub/server.np?base',
        'site=' + siteName,
        'searchCatalog=' + catalogAlias,
        'template=' + returnTemplate].join('&amp;');
    },

    // Convenience functions for certain common requests
    homePageURI: function (siteName, catalogAlias, returnTemplate) {
        return ['/netpub/server.np?base',
        'site=' + siteName,
        'catalog=' + catalogAlias,
        'template=' + returnTemplate].join('&amp;');
    },

    detailsURI: function (siteName, catalogAlias, returnTemplate, itemID) {
        return ['/netpub/server.np?find',
        'site=' + siteName,
        'catalog=' + catalogAlias,
        'template=' + returnTemplate,
        'field=itemid',
        'op=matches',
        'value=' + itemID].join('&amp;');
    },

    showAllURI: function (siteName, catalogAlias, returnTemplate, sortField, browse) {
        var uriBuffer = ['/netpub/server.np?quickfind',
        'site=' + siteName,
        'catalog=' + catalogAlias,
        'template=' + returnTemplate,
        'sorton=' + sortField];
        if (browse) {
            uriBuffer.push('browse=true');
        }

        return uriBuffer.join('&amp;');
    },

    searchByCategoryURI: function (siteName, catalogAlias, returnTemplate, categoryKeyword, sortField) {
        return ['/netpub/server.np?quickfind=' + categoryKeyword,
        'site=' + siteName,
        'catalog=' + catalogAlias,
        'template=' + returnTemplate,
        'sorton=' + sortField].join('&amp;');
    },

    quicksearchURI: function (siteName, catalogAlias, returnTemplate, searchTerm, sortField) {
        return ['/netpub/server.np?quickfind',
        'site=' + siteName,
        'catalog=' + catalogAlias,
        'template=' + returnTemplate,
        'value=' + searchTerm,
        'sorton=' + sortField].join('&amp;');
    },

    thumbnailURI: function (siteName, catalogAlias, itemID) {
        return ['/netpub/server.np?thumbnail',
        'itemid=' + itemID,
        'site=' + siteName,
        'catalog=' + catalogAlias].join('&amp;');
    },

    // previewURI(), originalURI(), and downloadURI() may return broken links
    // if the appropriate assets are not available to NetPublish
    // If you want the "Missing Preview" image to appear, call RecordSet.record.preview instead
    previewURI: function (siteName, catalogAlias, itemID) {
        return ['/netpub/server.np?preview',
        'itemid=' + itemID,
        'site=' + siteName,
        'catalog=' + catalogAlias].join('&amp;');
    },

    // If you want the "Missing Original" image or "Cannot Render Image" to appear, call RecordSet.record.original instead
    originalURI: function (siteName, catalogAlias, itemID) {
        return ['/netpub/server.np?original',
        'itemid=' + itemID,
        'site=' + siteName,
        'catalog=' + catalogAlias].join('&amp;');
    },

    // If you want the "Missing Original" image to appear, call RecordSet.record.original and append "&amp;download" instead
    downloadURI: function (siteName, catalogAlias, itemID) {
        return ['/netpub/server.np?original',
        'itemid=' + itemID,
        'site=' + siteName,
        'catalog=' + catalogAlias,
        'download'].join('&amp;');
    },

    // Untested
    isMissingOriginal: function () {
        return (RecordSet.record.original.indexOf('missing_original.gif') !== -1);
    },

    isMissingPreview: function () {
        return (RecordSet.record.preview.indexOf('missing_preview.gif') !== -1);
    }
};
